<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8">
    <title>{{ event_title }}</title>
    <link rel="stylesheet" href="style.css">
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>-->
    <style>
        .githubLink {
          color: #1C6EA4;
          text-decoration: none;
        }
        .bold-text {
          font-size: 1.2em;
          font-weight: bold;
        }
        #popup {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            overflow: hidden;
            padding: 1%;
            box-sizing: border-box;
            align-items: center;
            justify-content: center;
        }
        #popup-map-wrapper {
          position: relative;
          max-height: 98vh;
          max-width: 98vw;
          margin: 0 auto;
          display: flex;
          flex-direction: column;
          align-items: center;
          /*justify-content: center;*/
          box-sizing: border-box;
        }
        #map-container {
            position: relative;
            width: auto;
            display: flex;
            justify-content: center;
            flex: 1 1 auto;
            overflow: hidden;
        }
        #map-container img {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            display: block;
            object-fit: contain;
            z-index: 0;
        }
        #map-container canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
        }
        #popup-toolbar {
          position: absolute;
          top: 5px;
          right: 16px;
          font-size: 32px;
          color: black;
          z-index: 10;
        }
        #popup-close, #popup-save {
          cursor: pointer;
        }
        #popup-info {
          position: relative;
          line-height: 1.4;
          background: white;
          padding: 5px;
          box-sizing: border-box;
          box-shadow: 0 2 6px rgba(0,0,0,0.2);
          max-height: 30vh;
          z-index: 2;
          font-size: 14px;
          flex: 0 0 auto;
        }
        #tooltip {
          position: fixed;
          background: white;
          color: black;
          padding: 8px;
          font-size: 13px;
          border: 1px solid #ccc;
          box-shadow: 0 0 6px rgba(0,0,0,0.2);
          z-index: 2000;
          display: none;
          pointer-events: none;
        }
        #toggle-container {
          position: absolute;
          top: 10px;
          right: 10px;
          /*opacity: 0.5;*/
          /*transition: opacity 0.2s ease;*/
          background: white;
          padding: 8px;
          z-index: 1000;
          border: 1px solid #ccc;
          border-radius: 4px;
          font-family: sans-serif;
        }
        #toggle-container label {
          cursor: pointer;
        }
        /*#toggle-container label:hover {
          opacity: 1;
        }*/
        /*h1, h2 { text-align: center; }*/
    </style>
</head>
<body>
    <h1>{{ event_title }}</h1>
    <h2>{{ l.results_title }}</h2>
    <br>
    <table class="blueTable" id="results"></table>
    <div id="toggle-container">
      <label>
        <input type="checkbox" id="toggle-global" />
        {{ l.show_global }}
      </label>
    </div>

    <div id="popup">
      <div id="popup-map-wrapper">
        <div id="popup-info">
          <div id="popup-toolbar">
            <!--<span id="popup-save" title="Save image">ðŸ’¾</span>-->
            <span id="popup-close" title="{{ l.close_button }}" onclick="closePopup()">Ã—</span>
          </div>
          <div id="info-text"></div>
        </div>
        <div id="map-container">
          <img id="map-image" src="{{ map_filename }}">
          <canvas id="map-canvas"></canvas>
        </div>
      </div>
    </div>
    <div id="tooltip"></div>
    <p>
    Generated by 
    <a class="githubLink" href="https://github.com/sembruk/RogainingRoutes"><span>RogainingRoutes </span><svg version="1.1" width="16" height="16" viewBox="0 0 16 16" style="display: inline-block; fill: currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></a>
    <p>

  <script id="json-data" type="application/json">
  {{ embedded_json | safe }}
  </script>

  <script>

    const popup = document.getElementById("popup");
    const canvas = document.getElementById("map-canvas");
    const ctx = canvas.getContext("2d");
    const img = document.getElementById("map-image");
    const info = document.getElementById("popup-info");
    const infoText = document.getElementById("info-text");

    const data = JSON.parse(document.getElementById("json-data").textContent);
    const allTeams = Object.values(data.teams).flat();
    const cpCoords = data.cp_coords;

    function getQueryParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        showGlobal: params.get("abs") === "true" || params.get("abs") === "1"
      };
    }

    function closePopup() {
      popup.style.display = "none";
      tooltip.style.display = "none";
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawArrow(x1, y1, x2, y2, color) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const len = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx);
    
      const arrowLength = Math.min(len*0.7, 30);
      const arrow = [
        [len - arrowLength*0.9, 2],
        [len - arrowLength, 7],
        [len, 2],
        [len, -2],
        [len - arrowLength, -7],
        [len - arrowLength*0.9, -2]
      ];
    
      const rotated = arrow.map(([lx, ly]) => {
        const rx = Math.cos(angle)*lx - Math.sin(angle)*ly + x1;
        const ry = Math.sin(angle)*lx + Math.cos(angle)*ly + y1;
        return [rx, ry];
      });
    
      ctx.beginPath();
      ctx.fillStyle = color
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.moveTo(rotated[0][0], rotated[0][1]);
      for (let i = 1; i < rotated.length; i++) {
        ctx.lineTo(rotated[i][0], rotated[i][1]);
      }
      ctx.stroke();
      ctx.fill();
    }

    let currentTeam = null;
    let lineSegments = [];
    let needRedraw = true;

    function draw() {
      if (!currentTeam) return;
      //console.log('draw');
     
      const team = currentTeam;

      tooltip.style.display = "none";

      //console.log(canvas.width, canvas.height);
      const rect = img.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      scaleX = rect.width / img.naturalWidth;
      scaleY = rect.height / img.naturalHeight;
      offsetX = 0;
      imgWidth = rect.width;
      // Hack for Chrome
      if (scaleX > scaleY) {
          scaleX = scaleY;
          imgWidth = scaleX*img.naturalWidth;
          offsetX = (rect.width - imgWidth)/2;
          console.log(offsetX);
      }
      imgWidth = Math.round(imgWidth);
      info.style.width = `${imgWidth}px`;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
 
      // Hack for Firefox
      if (needRedraw) {
        needRedraw = false;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        setTimeout(() => {
          requestAnimationFrame(draw);
          requestAnimationFrame(draw);
        }, 200);
        return;
      }

      lineSegments = [];

      team.route.forEach((pt, i) => {
        const coord = cpCoords[pt.cp];
        if (!coord) return;
        [x, y] = coord;
        x *= scaleX;
        y *= scaleY;
        x += offsetX;

        if (i === 0) return;

        const prevCp = team.route[i - 1].cp;
        const prevCoord = cpCoords[prevCp];
        if (!prevCoord) return;
        let [px, py] = prevCoord;
        px *= scaleX;
        py *= scaleY;
        px += offsetX;

        const color = pt.color || "grey";

        ctx.beginPath();
        ctx.strokeStyle = "black";
        ctx.lineWidth = 6;
        ctx.shadowColor = "rgba(0,0,0,0.6)";
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.moveTo(px, py);
        ctx.lineTo(x, y);
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 4;
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.moveTo(px, py);
        ctx.lineTo(x, y);
        ctx.stroke();

        if (i === 1) {
          drawArrow(px, py, x, y, color);
        }

        lineSegments.push({
          x1: px, y1: py,
          x2: x, y2: y,
          desc: prevCp + '->' + pt.cp,
          data: team.route[i]
        });

        ctx.lineTo(x, y);
        
      });

      team.route.forEach(pt => {
        const coord = cpCoords[pt.cp];
        if (!coord) {
            console.log('no coord', pt.cp);
            return;
        }
        [x, y] = coord;
        x *= scaleX;
        y *= scaleY;
        x += offsetX;
        ctx.beginPath();
        ctx.fillStyle = "purple";
        ctx.arc(x, y, 3, 0, 2*Math.PI);
        ctx.fill();
      });

      infoText.innerHTML = `
        {{ l.team }}: <span style="font-size: 1.6em; font-weight: bold">${team.name}</span>
        <span class="bold-text">${team.members}</span><br>
        {{ l.points }}: <span class="bold-text">${team.points}</span>
        <span style="font-size: 0.8em; color: dimgray">
        ${team.points_per_km}/{{ l.km }}
        ${team.points_per_hour}/{{ l.h }}
        </span>
        {{ l.time }}: <span class="bold-text">${team.time}</span>
        {{ l.distance }}: <span class="bold-text">${team.distance_km} km</span>
        {{ l.speed }}: ${team.speed} {{ l.km_h }}
        {{ l.pace }}: ${team.pace} {{ l.min_km }}
        <br>
      `;

    }

    function showTeamPopup(bib) {
      const team = allTeams.find(t => t.bib == bib);
      if (!team) return;

      currentTeam = team;
      popup.style.display = "flex";

      if (img.complete) draw();
      else img.onload = draw;
    }

    function formatGroupPlace(group, place) {
      const medalEmojis = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
      if (place >= 1 && place <= 3) {
        return `${group}: ${medalEmojis[place - 1]}`;
      }
      return `${group}: ${place}`;
    }

    function renderTable(showGlobal) {
      const table = document.getElementById("results");
      const teamsByGroup = data.teams;
      const tableTitles = [
        "{{ l.place }}", 
        "{{ l.group_place }}", 
        {% if not hide_team_name %}"{{ l.team }}", {% endif %}
        "{{ l.members }}",
        "{{ l.time }}",
        "{{ l.points }}",
        "{{ l.penalty }}",
        "{{ l.total }}",
        "{{ l.km_title }}",
        "{{ l.pts_per_km }}",
        "{{ l.pts_per_h }}"
      ];

      table.innerHTML = "";

      if (showGlobal) {
        allTeams.sort((a, b) => {
          if (b.points !== a.points) return b.points - a.points;
          return a.time.localeCompare(b.time);
        });

        allTeams.forEach((team, index) => {
          team.absPlace = index + 1;
        });

        const headerRow = document.createElement("tr");
        tableTitles.forEach(title => {
          const th = document.createElement("th");
          th.textContent = title;
          headerRow.appendChild(th);
        });
        headerRow.style.background = "#1C6EA4";
        headerRow.style.color = "#FFF";
        table.appendChild(headerRow);

        allTeams.forEach(team => {
          const tr = document.createElement("tr");
          //boldStr = team.place > 0 && team.place < 4 ? "style=\"font-weight: bold\"" : "";
          tr.innerHTML = `
            <td>${team.absPlace}</td>
            <td>${formatGroupPlace(team.group, team.place)}</td>
            {% if not hide_team_name %}<td><a href="#" onclick="showTeamPopup(${team.bib});return false;">${team.name}</a></td><td>${team.members}</td>
            {% else %}<td><a href="#" onclick="showTeamPopup(${team.bib});return false;">${team.members}</a></td>{% endif %}
            <td>${team.time}</td>
            <td>${team.points}</td>
            <td>${team.penalty || ""}</td>
            <td><b>${team.points}</b></td>
            <td>${team.distance_km}</td>
            <td>${team.points_per_km}</td>
            <td>${team.points_per_hour}</td>
          `;
          table.appendChild(tr);
        });

        return;
      }

      for (const group in teamsByGroup) {
        const groupTeams = teamsByGroup[group];

        // Group header
        const titleRow = document.createElement("tr");
        titleRow.style.background = "#FFF";
        titleRow.innerHTML = `<th colspan="${tableTitles.length}">
            <h2 id="${group}">${group}</h2></th>`;
        table.appendChild(titleRow);

        // Column headers
        const headerRow = document.createElement("tr");
        tableTitles.forEach((title, index) => {
          if (index == 1) return;
          const th = document.createElement("th");
          th.textContent = title;
          headerRow.appendChild(th);
        });
        headerRow.style.background = "#1C6EA4";
        headerRow.style.color = "#FFF";
        table.appendChild(headerRow);

        // Team rows
        groupTeams.forEach(team => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${team.place}</td>
            {% if not hide_team_name %}<td><a href="#" onclick="showTeamPopup(${team.bib});return false;">${team.name}</a></td><td>${team.members}</td>
            {% else %}<td><a href="#" onclick="showTeamPopup(${team.bib});return false;">${team.members}</a></td>{% endif %}
            <td>${team.time}</td>
            <td>${team.sum}</td>
            <td>${team.penalty || ""}</td>
            <td><b>${team.points}</b></td>
            <td>${team.distance_km}</td>
            <td>${team.points_per_km}</td>
            <td>${team.points_per_hour}</td>
          `;
          table.appendChild(tr);
        });
      }
    }

    const tooltip = document.getElementById("tooltip");
    
    function showTooltip(x, y, html) {
      tooltip.innerHTML = html;
      //tooltip.style.left = `${x + 12}px`;
      //tooltip.style.top = `${y + 12}px`;
      tooltip.style.display = "block";

      const padding = 10;
      const tooltipRect = tooltip.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;

      if (x + tooltipRect.width + padding > windowWidth) {
        x = windowWidth - tooltipRect.width - padding;
      }

      if (y + tooltipRect.height + padding > windowHeight) {
        y = windowHeight - tooltipRect.height - padding;
      }

      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;
    }
    
    function hideTooltip() {
      tooltip.style.display = "none";
    }

    function isPointNearLine(x, y, seg, tolerance) {
      const { x1, y1, x2, y2 } = seg;
      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;
    
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      const param = len_sq !== 0 ? dot / len_sq : -1;
    
      let xx, yy;
    
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
    
      const dx = x - xx;
      const dy = y - yy;
      return (dx * dx + dy * dy) <= (tolerance * tolerance);
    }

    function tohhmmss(seconds) {
      const hh = Math.floor(seconds / 3600);
      const mm = Math.floor((seconds % 3600) / 60);
      const ss = Math.floor(seconds % 60);
      return `${hh}:${mm.toString().padStart(2, "0")}:${ss.toString().padStart(2, "0")}`;
    }

    //document.getElementById("popup-save").addEventListener("click", () => {
    //  const popup = document.getElementById("popup");
    //  html2canvas(popup).then(canvas => {
    //    const link = document.createElement("a");
    //    link.download = "team_map.jpg";
    //    link.href = canvas.toDataURL("image/jpg");
    //    link.click();
    //  });
    //});

    // Event listeners

    window.addEventListener("resize", () => {
      if (popup.style.display !== "none" && currentTeam) {
        draw();
      }
    });

    document.addEventListener("keydown", e => {
      if (e.key === "Escape") {
        closePopup();
      }
    });

    canvas.addEventListener("mousemove", e => {
    /*canvas.addEventListener("click", e => {*/
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const tolerance = 5;
      let found = null;

      for (const segment of lineSegments) {
        if (isPointNearLine(mouseX, mouseY, segment, tolerance)) {
          found = segment;
          break;
        }
      }

      if (found) {
        split_str = tohhmmss(found.data.split);
        speed = 0
        if (found.data.split > 0) {
          speed = found.data.leg_len*3600/found.data.split;
        }
        ptH = found.data.points*3600/found.data.split;
        legLength = Math.round(found.data.leg_len*1000);
        ptKm = found.data.points/found.data.leg_len;
        showTooltip(e.clientX, e.clientY, `
          {{ l.segment }}: <b>${found.desc}</b><br>
          {{ l.split }}: ${split_str}<br>
          {{ l.length }}: ${legLength} {{ l.m }}<br>
          {{ l.speed }}: ${speed.toFixed(2)} {{ l.km_h }}<br>
          {{ l.pace }}: ${found.data.pace} {{ l.min_km }}<br>
          {{ l.points }}: ${found.data.points}<br>
          <span style="color: gray;">${ptKm.toFixed(2)}/{{ l.km }}
          ${ptH.toFixed(2)}/{{ l.h }}<br></span>
          {{ l.rank }}: ${found.data.leg_ranking}
        `);
      } else {
        hideTooltip();
      }
    })

    document.addEventListener("DOMContentLoaded", () => {
      const toggleCheckbox = document.getElementById("toggle-global");
      const { showGlobal } = getQueryParams();
    
      toggleCheckbox.checked = showGlobal;
      renderTable(showGlobal);
    
      toggleCheckbox.addEventListener("change", () => {
        renderTable(toggleCheckbox.checked);
      });
    });
  </script>
</body>
</html>
